-- Identity
id : (A : U) -> A -> A
id := \A. \a. a

#check id (T x T) (*, *)

-- Projections
fst : (A : U) -> (B : A -> U) -> (a : A) x B a -> A
fst := \A. \B. \p. ind[(a : A) x B a](A, a. b. a, p)

#check fst

snd : (A : U) -> (B : A -> U) -> (p : (a : A) x B a) -> B (fst A B p)
snd := \A. \B. \p. ind[(a : A) x B a](p. B (fst A B p), a. b. b, p)

#check snd

-- Type theoretic axiom of choice
ac : (A : U) -> (B : U) -> (R : A -> B -> U) -> ((a : A) -> (b : B) x (R a b)) -> ((f : A -> B) x ((a : A) -> (R a (f a))))
ac := \A. \B. \R. \g. (\(a : A). fst B (\(b : B). R a b) (g a), \(a : A). snd B (\(b : B). R a b) (g a))

#check ac

-- Boolean
Bool := T + T

#check Bool

true : Bool
true := inl(*)

false : Bool
false := inr(*)

#check true
#check false

-- Conditional
ifThenElse : (C : U) -> Bool -> C -> C -> C
ifThenElse := \C. \b. \cT. \c2. ind[Bool](C, a. cT, b. c2, b)

#check ifThenElse

not : Bool -> Bool
not := \b. ifThenElse Bool b false true

#check not false

-- Uniqueness
uniqT : (a : T) -> a = *
uniqT := \b. ind[T](a. a = *, refl[*], b)

#check uniqT

-- Initial and terminal
terminal : (A : U) -> T
terminal := \A. *

#check terminal

initial : (A : U) -> _|_ -> A
initial := \A. \a. ind[_|_](A, a)

#check initial

-- Identity Equivalence Relation
idRefl : (A : U) -> (a : A) -> a = a
idRefl := \A. \a. refl[a]

#check idRefl

idSymm : (A : U) -> (a : A) -> (b : A) -> a = b -> b = a
idSymm := \A. \a. \b. \p. ind[=[A]](a. b. p. b = a, z. refl[z], a, b, p) 

#check idSymm

idTransLemma : (A : U) -> (a : A) -> (b : A) -> a = b -> (c : A) -> b = c -> a = c
idTransLemma := \A. \a. \b. \p. ind[=[A]](a. b. p. (c : A) -> b = c -> a = c, z. \c. \q. ind[=[A]](a. c. p. a = c, z'. refl[z'], z, c, q), a, b, p)

idTrans : (A : U) -> (a : A) -> (b : A) -> (c : A) -> a = b -> b = c -> a = c
idTrans := \A. \a. \b. \c. \p. idTransLemma A a b p c

#check idTrans

-- Natural Numbers
a : Nat
a := 5

#check a

double : Nat -> Nat
double := \n. ind[Nat](Nat, 0, n. y. succ(succ(y)), n)

#check double a

add : Nat -> Nat -> Nat
add := \n. ind[Nat](Nat -> Nat, \n. n, n. g. \m. succ(g m), n)

#check add
#check add 2 2

twoPlusTwoIsFour : add 2 2 = 4
twoPlusTwoIsFour := refl[4]

#check twoPlusTwoIsFour

-- HoTT Ex 1.8
multiply : Nat -> Nat -> Nat
multiply := \n. ind[Nat](Nat -> Nat, \n. 0, n'. g. \m. add m (g m), n)

#check multiply 2 4

lMul0 : (A : U) -> (a : A) -> multiply 0 a = 0
lMul0 := \A. \a. refl[0]

#check lMul0

powFlipped : Nat -> Nat -> Nat
powFlipped := \n. ind[Nat](Nat -> Nat, \n. 1, n'. g. \m. multiply m (g m), n)

flip : (A : U) -> (B : U) -> (C : U) -> (A -> B -> C) -> B -> A -> C
flip := \A. \B. \C. \f. \b. \a. f a b

pow := flip Nat Nat Nat powFlipped

#check pow 2 5
